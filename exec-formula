#!/usr/bin/env node

/**
 * Formula Executor - Reads multiple formula files and executes them with deduplication
 * Usage: ./exec-formula path/to/formula1.formula path/to/formula2.formula ...
 * All formulas must be from the same table (determined by directory structure)
 */

import { readFileSync } from 'fs';
import { evaluateFormula, generateSQL, mapPostgresType } from './formula-compiler.js';
import { basename, dirname } from 'path';
import pkg from 'pg';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const { Client } = pkg;

// Database connection string from environment
const connectionString = process.env.DATABASE_URL;

if (!connectionString) {
  console.error('❌ Error: DATABASE_URL environment variable is not set');
  console.error('   Please create a .env file with: DATABASE_URL=your_connection_string');
  process.exit(1);
}

// Extract table name from formula file path
function extractTableName(filePath) {
  // Expected structure: examples/table/{table_name}/formula.formula
  const pathParts = filePath.split('/');
  const tableIndex = pathParts.indexOf('table');
  
  if (tableIndex >= 0 && tableIndex + 1 < pathParts.length) {
    return pathParts[tableIndex + 1];
  }
  
  // Fallback: use directory name if not in expected structure
  const dir = dirname(filePath);
  const dirName = basename(dir);
  return dirName === '.' ? 'submission' : dirName; // Default to submission
}

// Generate field name from formula file path
function generateFieldName(filePath) {
  const fileName = basename(filePath, '.formula');
  return fileName.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
}

// Build column list for any table using metadata system
async function getColumnListForTable(tableName, client) {
  const query = `
    SELECT tf.name, tf.data_type
    FROM table_field tf
    JOIN table_info ti ON tf.table_info = ti.id
    WHERE ti.table_name = $1
    ORDER BY tf.name
  `;
  
  const result = await client.query(query, [tableName]);
  
  if (result.rows.length === 0) {
    throw new Error(`Table '${tableName}' not found in metadata system`);
  }
  
  const columnList = {};
  for (const row of result.rows) {
    columnList[row.name] = mapPostgresType(row.data_type);
  }
  
  return columnList;
}

// Build relationship info for a table using metadata system
async function getRelationshipsForTable(tableName, client) {
  const query = `
    SELECT rl.col_name, rl.target_table_name
    FROM relationship_lookups rl
    WHERE rl.source_table_name = $1
  `;
  
  const result = await client.query(query, [tableName]);
  const relationships = {};
  
  for (const row of result.rows) {
    const targetColumnList = await getColumnListForTable(row.target_table_name, client);
    
    // Use the base name (without _id suffix) as the key
    const relationshipKey = row.col_name.replace(/_id$/, '');
    
    relationships[relationshipKey] = {
      joinColumn: row.col_name,
      columnList: targetColumnList
    };
  }
  
  return relationships;
}

// Build inverse relationship info for a table using metadata system
async function getInverseRelationshipsForTable(tableName, client) {
  const query = `
    SELECT rl.source_table_name, rl.col_name, rl.target_table_name
    FROM relationship_lookups rl
    WHERE rl.target_table_name = $1
  `;
  
  const result = await client.query(query, [tableName]);
  const inverseRelationships = {};
  
  for (const row of result.rows) {
    // Use naming pattern: {source_table_name}s_{col_name}
    const relationshipName = `${row.source_table_name}s_${row.col_name}`;
    
    const sourceColumnList = await getColumnListForTable(row.source_table_name, client);
    const sourceRelationships = await getRelationshipsForTable(row.source_table_name, client);
    
    inverseRelationships[relationshipName] = {
      tableName: row.source_table_name,
      columnList: sourceColumnList,
      joinColumn: row.col_name,
      relationshipInfo: sourceRelationships
    };
  }
  
  return inverseRelationships;
}

async function main() {
  try {
    // Get formula file paths from command line arguments
    const formulaPaths = process.argv.slice(2);
    
    if (formulaPaths.length === 0) {
      console.error('❌ Usage: ./exec-formula path/to/formula1.formula [path/to/formula2.formula ...]');
      console.error('   Example: ./exec-formula examples/table/submission/business_summary.formula examples/table/submission/risk_assessment.formula');
      process.exit(1);
    }
    
    console.log(`🚀 Formula Executor - Processing ${formulaPaths.length} formula(s)\n`);
    
    // Extract table names and validate they're all the same
    const tableNames = formulaPaths.map(extractTableName);
    const uniqueTableNames = [...new Set(tableNames)];
    
    if (uniqueTableNames.length > 1) {
      console.error('❌ Error: All formulas must be from the same table');
      console.error(`   Found formulas from tables: ${uniqueTableNames.join(', ')}`);
      console.error('   Please ensure all formula files are from the same table directory');
      process.exit(1);
    }
    
    const tableName = uniqueTableNames[0];
    console.log(`📋 Target table: ${tableName}`);
    
    // Read and parse formulas
    console.log('📄 Reading formulas from files...');
    const formulas = [];
    const formulaData = {};
    
    for (let i = 0; i < formulaPaths.length; i++) {
      const filePath = formulaPaths[i];
      const fieldName = generateFieldName(filePath);
      const formulaContent = readFileSync(filePath, 'utf8').trim();
      
      formulas.push({
        path: filePath,
        fieldName: fieldName,
        content: formulaContent
      });
      
      console.log(`  ${i + 1}. ${fieldName}: ${formulaContent}`);
    }
    
    // Connect to database for metadata lookup
    console.log('\n🔌 Connecting to PostgreSQL database...');
    const client = new Client({ connectionString });
    await client.connect();
    
    // Build context for the table using metadata system
    console.log('📋 Loading table metadata...');
    const columnList = await getColumnListForTable(tableName, client);
    
    console.log('🔗 Loading relationship metadata...');
    const relationshipInfo = await getRelationshipsForTable(tableName, client);
    
    console.log('🔗 Loading inverse relationship metadata...');
    const inverseRelationshipInfo = await getInverseRelationshipsForTable(tableName, client);
    
    const context = {
      tableName: tableName,
      columnList: columnList,
      relationshipInfo: relationshipInfo,
      inverseRelationshipInfo: inverseRelationshipInfo
    };
    
    console.log('\n🔄 Compiling formulas to intents...');
    
    // Compile each formula to intents
    const results = {};
    const compilationResults = [];
    
    for (const formula of formulas) {
      try {
        const result = evaluateFormula(formula.content, context);
        results[formula.fieldName] = result;
        compilationResults.push({
          ...formula,
          result: result,
          success: true
        });
        console.log(`  ✅ ${formula.fieldName}: Compiled successfully`);
      } catch (error) {
        console.log(`  ❌ ${formula.fieldName}: ${error.message}`);
        compilationResults.push({
          ...formula,
          error: error,
          success: false
        });
      }
    }
    
    // Check if any formulas failed
    const failedFormulas = compilationResults.filter(r => !r.success);
    if (failedFormulas.length > 0) {
      console.error(`\n❌ ${failedFormulas.length} formula(s) failed to compile. Aborting.`);
      process.exit(1);
    }
    
    console.log('\n📊 Compilation Analysis:');
    console.log('='.repeat(60));
    
    let totalJoinIntents = new Set();
    let totalAggregateIntents = new Set();
    
    compilationResults.forEach((formula, index) => {
      if (formula.success) {
        console.log(`\n${index + 1}. ${formula.fieldName}:`);
        console.log(`   Expression ID: ${formula.result.expression.semanticId}`);
        console.log(`   Join Intents: ${formula.result.joinIntents.length}`);
        formula.result.joinIntents.forEach((join, i) => {
          console.log(`     ${i+1}. ${join.semanticId}`);
          totalJoinIntents.add(join.semanticId);
        });
        console.log(`   Aggregate Intents: ${formula.result.aggregateIntents.length}`);
        formula.result.aggregateIntents.forEach((agg, i) => {
          console.log(`     ${i+1}. ${agg.semanticId}`);
          totalAggregateIntents.add(agg.semanticId);
          agg.internalJoins.forEach(join => totalJoinIntents.add(join.semanticId));
        });
      }
    });
    
    console.log('\n🔧 Generating optimized SQL with deduplication...');
    const sqlResult = generateSQL(results, tableName);
    
    console.log('\n📈 Deduplication Analysis:');
    console.log('='.repeat(60));
    console.log(`Total Unique Join Intents: ${totalJoinIntents.size}`);
    console.log(`Total Unique Aggregate Intents: ${totalAggregateIntents.size}`);
    console.log(`Actual JOINs in Generated SQL: ${(sqlResult.fromClause.match(/LEFT JOIN/g) || []).length}`);
    console.log(`Actual Aggregate Subqueries: ${sqlResult.aggregateSubqueries.length}`);
    console.log(`SELECT Expressions: ${sqlResult.selectExpressions.length}`);
    
    console.log('\n📝 Generated Optimized SQL:');
    console.log('='.repeat(60));
    console.log(sqlResult.sql);
    
    console.log('\n⚡ Executing SQL query...\n');
    const queryResult = await client.query(sqlResult.sql + ' LIMIT 5');
    
    console.log('📊 Results:');
    console.log('='.repeat(60));
    
    if (queryResult.rows.length === 0) {
      console.log('No results found');
    } else {
      console.log(`Found ${queryResult.rows.length} rows:\n`);
      queryResult.rows.forEach((row, index) => {
        console.log(`Row ${index + 1}:`);
        Object.keys(results).forEach(fieldName => {
          console.log(`  ${fieldName}: ${row[fieldName] || 'NULL'}`);
        });
        console.log('');
      });
    }
    
    console.log('='.repeat(60));
    console.log(`\n✅ Multi-formula execution completed successfully!`);
    console.log(`\n🎯 Processed ${formulaPaths.length} formula(s) from table '${tableName}':`);
    formulas.forEach((formula, index) => {
      console.log(`  ${index + 1}. ${formula.fieldName} (${basename(formula.path)})`);
    });
    console.log('\n🎯 Deduplication Benefits:');
    console.log('  ✓ Shared joins between formulas are deduplicated');
    console.log('  ✓ Shared expressions within same joins are reused');
    console.log('  ✓ Aggregate subqueries are optimized across all formulas');
    console.log('  ✓ Single query execution for multiple formula results');
    
    await client.end();
    
  } catch (error) {
    console.error('❌ Error:', error.message);
    if (error.position !== undefined) {
      console.error(`   Position: ${error.position}`);
    }
    if (error.stack) {
      console.error('Stack trace:', error.stack);
    }
    process.exit(1);
  }
}

main(); 