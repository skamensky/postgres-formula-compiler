#!/usr/bin/env node

/**
 * Formula Executor - Reads multiple formula files and executes them with deduplication
 * Usage: ./exec-formula [--output format] path/to/formula1.formula path/to/formula2.formula ...
 * Formats: json, html, markdown (default: console)
 * All formulas must be from the same table (determined by directory structure)
 */

import { readFileSync } from 'fs';
import { 
  extractTableName,
  generateFieldName,
  buildTableContext,
  compileFormulas,
  analyzeCompilation,
  buildReport,
  formatReport
} from './src/report-builder.js';
import { basename } from 'path';
import { createDatabaseClient } from './web/db-client.js';

// Parse command line arguments
function parseArguments() {
  const args = process.argv.slice(2);
  let outputFormat = 'console';
  let formulaPaths = [];
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--output' && i + 1 < args.length) {
      outputFormat = args[i + 1];
      i++; // Skip the next argument as it's the format value
    } else if (args[i].endsWith('.formula')) {
      formulaPaths.push(args[i]);
    }
  }
  
  // Validate output format
  const validFormats = ['console', 'json', 'html', 'markdown'];
  if (!validFormats.includes(outputFormat)) {
    console.error(`‚ùå Error: Invalid output format '${outputFormat}'`);
    console.error(`   Valid formats: ${validFormats.join(', ')}`);
    process.exit(1);
  }
  
  return { outputFormat, formulaPaths };
}

// Output formatters
const formatters = {
  console: {
    // Current console output - will be handled in main function
    format: (data) => data
  },
  
  json: {
    format: (data) => {
      return JSON.stringify(data, null, 2);
    }
  },
  
  html: {
    format: (data) => {
      const { metadata, results, sql, analysis } = data;
      
      return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formula Execution Results</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
        .header { background: #f4f4f4; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .section { margin-bottom: 30px; }
        .section h2 { color: #333; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
        .formula { background: #f9f9f9; padding: 10px; margin: 10px 0; border-left: 4px solid #007cba; }
        .sql { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .sql code { font-family: 'Courier New', monospace; white-space: pre; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .metric { display: inline-block; margin: 10px 20px 10px 0; }
        .metric strong { color: #007cba; }
        .null { color: #999; font-style: italic; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ Formula Execution Results</h1>
        <p><strong>Table:</strong> ${metadata.tableName}</p>
        <p><strong>Formulas Processed:</strong> ${metadata.formulaCount}</p>
        <p><strong>Execution Time:</strong> ${new Date().toISOString()}</p>
    </div>

    <div class="section">
        <h2>üìÑ Formulas</h2>
        ${metadata.formulas.map((formula, i) => `
        <div class="formula">
            <strong>${i + 1}. ${formula.fieldName}</strong><br>
            <code>${formula.content}</code><br>
            <small>Source: ${formula.path}</small>
        </div>
        `).join('')}
    </div>

    <div class="section">
        <h2>üìà Analysis</h2>
        <div class="metric"><strong>Join Intents:</strong> ${analysis.totalJoinIntents}</div>
        <div class="metric"><strong>Aggregate Intents:</strong> ${analysis.totalAggregateIntents}</div>
        <div class="metric"><strong>Actual JOINs:</strong> ${analysis.actualJoins}</div>
        <div class="metric"><strong>Subqueries:</strong> ${analysis.subqueries}</div>
        <div class="metric"><strong>SELECT Expressions:</strong> ${analysis.selectExpressions}</div>
    </div>

    <div class="section">
        <h2>üìù Generated SQL</h2>
        <div class="sql">
            <code>${sql.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>
        </div>
    </div>

    <div class="section">
        <h2>üìä Results</h2>
        ${results.length === 0 ? '<p>No results found</p>' : `
        <table>
            <thead>
                <tr>
                    ${Object.keys(results[0]).map(key => `<th>${key}</th>`).join('')}
                </tr>
            </thead>
            <tbody>
                ${results.map(row => `
                <tr>
                    ${Object.keys(row).map(key => `<td>${row[key] === null ? '<span class="null">NULL</span>' : row[key]}</td>`).join('')}
                </tr>
                `).join('')}
            </tbody>
        </table>
        `}
    </div>
</body>
</html>`;
    }
  },
  
  markdown: {
    format: (data) => {
      const { metadata, results, sql, analysis } = data;
      
      return `# üöÄ Formula Execution Results

## üìã Metadata
- **Table:** ${metadata.tableName}
- **Formulas Processed:** ${metadata.formulaCount}
- **Execution Time:** ${new Date().toISOString()}

## üìÑ Formulas

${metadata.formulas.map((formula, i) => `### ${i + 1}. ${formula.fieldName}
${'```'}
${formula.content}
${'```'}
**Source:** ${formula.path}
`).join('\n')}

## üìà Analysis

| Metric | Value |
|--------|-------|
| Join Intents | ${analysis.totalJoinIntents} |
| Aggregate Intents | ${analysis.totalAggregateIntents} |
| Actual JOINs | ${analysis.actualJoins} |
| Subqueries | ${analysis.subqueries} |
| SELECT Expressions | ${analysis.selectExpressions} |

## üìù Generated SQL

${'```'}sql
${sql}
${'```'}

## üìä Results

${results.length === 0 ? 'No results found' : `
| ${Object.keys(results[0]).join(' | ')} |
| ${Object.keys(results[0]).map(() => '---').join(' | ')} |
${results.map(row => `| ${Object.keys(row).map(key => row[key] === null ? '*NULL*' : row[key]).join(' | ')} |`).join('\n')}
`}

---
*Generated by Formula Executor*
`;
    }
  }
};

// All functions are now imported from src/report-builder.js (battle-tested source of truth)

async function main() {
  try {
    // Parse command line arguments
    const { outputFormat, formulaPaths } = parseArguments();
    
    if (formulaPaths.length === 0) {
      console.error('‚ùå Usage: ./exec-formula [--output format] path/to/formula1.formula [path/to/formula2.formula ...]');
      console.error('   Example: ./exec-formula examples/table/submission/business_summary.formula examples/table/submission/risk_assessment.formula');
      console.error('   Formats: console (default), json, html, markdown');
      if (process.argv.length > 4) {
        console.error(`   Note: ${process.argv.length - 4} non-formula files were filtered out`);
      }
      process.exit(1);
    }
    
    // Only show progress messages for console output
    if (outputFormat === 'console') {
      console.log(`üöÄ Formula Executor - Processing ${formulaPaths.length} formula(s)\n`);
    }
    
    // Extract table names and validate they're all the same (using proven functions)
    const tableNames = formulaPaths.map(extractTableName);
    const uniqueTableNames = [...new Set(tableNames)];
    
    if (uniqueTableNames.length > 1) {
      console.error('‚ùå Error: All formulas must be from the same table');
      console.error(`   Found formulas from tables: ${uniqueTableNames.join(', ')}`);
      console.error('   Please ensure all formula files are from the same table directory');
      process.exit(1);
    }
    
    const tableName = uniqueTableNames[0];
    if (outputFormat === 'console') {
      console.log(`üìã Target table: ${tableName}`);
      console.log('üìÑ Reading formulas from files...');
    }
    
    // Read and parse formulas using proven functions
    const formulas = [];
    for (let i = 0; i < formulaPaths.length; i++) {
      const filePath = formulaPaths[i];
      const fieldName = generateFieldName(filePath);
      const formulaContent = readFileSync(filePath, 'utf8').trim();
      
      formulas.push({
        path: filePath,
        fieldName: fieldName,
        content: formulaContent
      });
      
      if (outputFormat === 'console') {
        console.log(`  ${i + 1}. ${fieldName}: ${formulaContent}`);
      }
    }
    
    // Use the proven buildReport function to do all the heavy lifting
    if (outputFormat === 'console') {
      console.log('\nÔøΩ Connecting to database and building report...');
    }
    
    const client = createDatabaseClient();
    const report = await buildReport({
      tableName,
      formulas,
      client,
      limit: 5 // Default limit for exec-formula
    });
    
    // Handle output formatting
    if (outputFormat === 'console') {
      // Custom console output for exec-formula (preserving the existing detailed output)
      console.log(`üìä Report for table: ${tableName}`);
      console.log(`üìÅ Formulas processed: ${report.metadata.formulaCount}`);
      console.log(`üîó Tables loaded: ${report.metadata.totalTablesLoaded}`);  
      console.log(`üìÑ Results: ${report.results.length} rows\n`);
      
      console.log('üìä Results:');
      console.log('='.repeat(60));
      
      if (report.results.length === 0) {
        console.log('No results found');
      } else {
        console.log(`Found ${report.results.length} rows:\n`);
        report.results.forEach((row, index) => {
          console.log(`Row ${index + 1}:`);
          formulas.forEach(formula => {
            console.log(`  ${formula.fieldName}: ${row[formula.fieldName] || 'NULL'}`);
          });
          console.log('');
        });
      }
      
      console.log('='.repeat(60));
      console.log(`\n‚úÖ Multi-formula execution completed successfully!`);
      console.log(`\nüéØ Processed ${formulaPaths.length} formula(s) from table '${tableName}':`);
      formulas.forEach((formula, index) => {
        console.log(`  ${index + 1}. ${formula.fieldName} (${basename(formula.path)})`);
      });
      console.log('\nüéØ Deduplication Benefits:');
      console.log('  ‚úì Shared joins between formulas are deduplicated');
      console.log('  ‚úì Shared expressions within same joins are reused');
      console.log('  ‚úì Aggregate subqueries are optimized across all formulas');
      console.log('  ‚úì Single query execution for multiple formula results');
      
      // Show debug info for console mode
      console.log('\nüìà Deduplication Analysis:');
      console.log('='.repeat(60));
      console.log(`Total Unique Join Intents: ${report.compilation.analysis.totalJoinIntents}`);
      console.log(`Total Unique Aggregate Intents: ${report.compilation.analysis.totalAggregateIntents}`);
      console.log(`Actual JOINs in Generated SQL: ${report.performance.actualJoins}`);
      console.log(`Actual Aggregate Subqueries: ${report.sql.aggregateSubqueries.length}`);
      console.log(`SELECT Expressions: ${report.sql.selectExpressions.length}`);
      
      console.log('\nüìù Generated Optimized SQL:');
      console.log('='.repeat(60));
      console.log(report.sql.query);
    } else {
      // Use the formatReport function for structured outputs
      const formattedOutput = formatReport(report, outputFormat);
      console.log(formattedOutput);
    }
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    if (error.position !== undefined) {
      console.error(`   Position: ${error.position}`);
    }
    if (error.stack) {
      console.error('Stack trace:', error.stack);
    }
    process.exit(1);
  }
}

main(); 